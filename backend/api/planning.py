from fastapi import APIRouter, HTTPException, Body
from pydantic import BaseModel
from typing import List, Optional
from backend.models import HealthState, UserProfile
from src.core.llm_reasoning import get_llm_generator
from backend.store import BackendStore

router = APIRouter()

class TaskGenerationRequest(BaseModel):
    state: HealthState
    user_profile: UserProfile
    goal: str

class RecommendedTask(BaseModel):
    title: str
    duration: int
    domain: str
    reason: str
    is_blocked: bool = False
    block_reason: Optional[str] = None

class TaskGenerationResponse(BaseModel):
    tasks: List[RecommendedTask]

@router.post("/generate", response_model=TaskGenerationResponse)
async def generate_tasks(request: TaskGenerationRequest):
    try:
        generator = get_llm_generator()
        
        # Convert Pydantic models to dicts for the generator
        state_dict = request.state.model_dump()
        profile_dict = request.user_profile.model_dump()
        
        tasks_data = generator.generate_daily_tasks(
            state_snapshot=state_dict,
            user_goal=request.goal,
            user_profile=profile_dict
        )
        
        # Save to store
        BackendStore().update_daily_tasks(tasks_data)
        
        # Ensure ID is not required in response model if it's not generated by LLM
        # or normalize it
        
        return TaskGenerationResponse(tasks=tasks_data)
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

class TaskAnalysisRequest(BaseModel):
    task_title: str
    state: HealthState

class TaskAnalysisResponse(BaseModel):
    domain: str
    is_safe: bool
    reason: str

@router.post("/analyze_task", response_model=TaskAnalysisResponse)
async def analyze_task(request: TaskAnalysisRequest):
    try:
        generator = get_llm_generator()
        state_dict = request.state.model_dump()
        
        result = generator.analyze_single_task(
            task_title=request.task_title,
            state_snapshot=state_dict
        )
        
        return TaskAnalysisResponse(**result)
    except Exception as e:
        # Fallback
        return TaskAnalysisResponse(domain="productivity", is_safe=True, reason="Analysis failed, default applied.")
